<div class="game-container">
  <div class="game-layout">
    <div class="game-area">
  @if (game()?.status === GameStatus.MULLIGAN) {
    <div class="mulligan-section">
      <div class="turn-info">
        <div class="player-badge active">
          {{ player1Name }}
          <span class="hand-size">Hand: {{ player1HandSize }}</span>
          <span class="deck-size">Deck: {{ player1DeckSize }}</span>
        </div>
        <div class="turn-center">
          <span class="turn-number">Mulligan Phase</span>
          <span class="vs-label">VS</span>
        </div>
        <div class="player-badge active">
          {{ player2Name }}
          <span class="hand-size">Hand: {{ player2HandSize }}</span>
          <span class="deck-size">Deck: {{ player2DeckSize }}</span>
        </div>
      </div>

      @if (selectingBottomCards) {
        <div class="hand-area bottom-selection">
          <div class="hand-label">Select {{ bottomCardCount }} card{{ bottomCardCount > 1 ? 's' : '' }} to put on the bottom of your library</div>
          <div class="selection-count">Selected: {{ selectedCardIndices.size }} / {{ bottomCardCount }}</div>
          <div class="hand-cards">
            @for (card of hand; track $index) {
              <app-card-display
                [card]="card"
                class="selectable"
                [class.selected]="isCardSelected($index)"
                (click)="toggleCardSelection($index)"
                (mouseenter)="onCardHover(card)"
                (mouseleave)="onCardHoverEnd()">
                @if (isCardSelected($index)) {
                  <div class="card-selected-badge">Bottom</div>
                }
              </app-card-display>
            }
          </div>
          <div class="mulligan-actions">
            <button class="btn-keep" (click)="confirmBottomCards()" [disabled]="!canConfirmBottom">Confirm Selection</button>
          </div>
        </div>
      } @else {
        <div class="hand-area">
          <div class="hand-label">Your Hand ({{ hand.length }} cards)</div>
          <div class="hand-cards">
            @for (card of hand; track $index) {
              <app-card-display [card]="card" (mouseenter)="onCardHover(card)" (mouseleave)="onCardHoverEnd()" />
            }
          </div>
        </div>

        <div class="mulligan-info">
          @if ((game()?.mulliganCount ?? 0) > 0) {
            <span class="mulligan-count">Mulligan count: {{ game()?.mulliganCount }}</span>
          }
        </div>

        @if (!selfKept) {
          <div class="mulligan-actions">
            <button class="btn-keep" (click)="keepHand()">Keep Hand</button>
            <button class="btn-mulligan" (click)="takeMulligan()" [disabled]="!canMulligan">Mulligan</button>
          </div>
        } @else {
          <div class="mulligan-actions">
            <span class="kept-label">You kept your hand.</span>
          </div>
        }
      }

      <div class="opponent-mulligan-status">
        @if (opponentKept) {
          <span>Opponent kept their hand.</span>
        } @else {
          <span>Opponent is deciding...</span>
        }
      </div>
    </div>
  }

  @if (game()?.status === GameStatus.RUNNING || game()?.status === GameStatus.FINISHED) {
    @if (choice.targeting) {
      <div class="combat-banner targeting-banner">
        @if (choice.targetingForPlayer) {
          <span>Select a target player for {{ choice.targetingCardName }}</span>
        } @else if (choice.targetingAllowedTypes.includes('Enchantment')) {
          <span>Select a target Aura for {{ choice.targetingCardName }}</span>
        } @else if (choice.targetingBlockingThis) {
          <span>Select a creature blocking {{ choice.targetingCardName }}</span>
        } @else if (choice.targetingRequiresAttacking) {
          <span>Select a target attacking creature for {{ choice.targetingCardName }}</span>
        } @else {
          <span>Select a target creature for {{ choice.targetingCardName }}</span>
        }
        <button class="btn-confirm-combat" (click)="choice.cancelTargeting()">Cancel</button>
      </div>
    }

    @if (choice.targetingSpell) {
      <div class="combat-banner spell-targeting-banner">
        <span>Select a spell on the stack to counter with {{ choice.targetingSpellCardName }}</span>
        <button class="btn-confirm-combat" (click)="choice.cancelSpellTargeting()">Cancel</button>
      </div>
    }

    @if (choice.multiTargeting) {
      <div class="combat-banner targeting-banner">
        @if (choice.multiTargetForPlayer) {
          <span>Select targets for {{ choice.multiTargetCardName }} ({{ choice.multiTargetSelectedIds().length }}/{{ choice.multiTargetMaxCount }})</span>
        } @else {
          <span>Select target creatures for {{ choice.multiTargetCardName }} ({{ choice.multiTargetSelectedIds().length }}/{{ choice.multiTargetMaxCount }})</span>
        }
        <button class="btn-confirm-combat" (click)="choice.confirmMultiTargets()" [disabled]="choice.multiTargetSelectedIds().length < choice.multiTargetMinCount">Confirm</button>
        <button class="btn-confirm-combat" (click)="choice.cancelMultiTargeting()">Cancel</button>
      </div>
    }

    @if (choice.convoking) {
      <div class="combat-banner targeting-banner">
        <span>Tap creatures to help cast {{ choice.convokeCardName }} ({{ choice.convokeSelectedCreatureIds().length }} tapped)</span>
        <button class="btn-confirm-combat" (click)="choice.confirmConvoke()">Cast</button>
        <button class="btn-confirm-combat" (click)="choice.skipConvoke()">Skip Convoke</button>
        <button class="btn-confirm-combat" (click)="choice.cancelConvoke()">Cancel</button>
      </div>
    }

    @if (choice.reorderingLibrary) {
      <div class="combat-banner reorder-banner">
        <span>{{ choice.reorderPrompt }}</span>
      </div>
      <div class="reorder-zone">
        @if (choice.reorderAvailableCards.length > 0) {
          <div class="reorder-section">
            <div class="reorder-label">Click cards to set their order (top to bottom):</div>
            <div class="reorder-cards">
              @for (item of choice.reorderAvailableCards; track item.originalIndex) {
                <app-card-display
                  [card]="item.card"
                  class="reorder-card available"
                  (click)="choice.selectReorderCard(item.originalIndex)"
                  (mouseenter)="onCardHover(item.card)"
                  (mouseleave)="onCardHoverEnd()" />
              }
            </div>
          </div>
        }
        @if (choice.reorderPlacedCards.length > 0) {
          <div class="reorder-section">
            <div class="reorder-label">New order (top of library first):</div>
            <div class="reorder-cards">
              @for (item of choice.reorderPlacedCards; track item.originalIndex) {
                <div class="reorder-card-wrapper">
                  <div class="reorder-position-badge">{{ item.position }}</div>
                  <app-card-display
                    [card]="item.card"
                    class="reorder-card placed"
                    (mouseenter)="onCardHover(item.card)"
                    (mouseleave)="onCardHoverEnd()" />
                </div>
              }
            </div>
          </div>
        }
        <div class="reorder-actions">
          <button class="btn-confirm-combat" (click)="choice.undoLastReorderCard()" [disabled]="choice.reorderOriginalIndices.length === 0">Undo</button>
          <button class="btn-confirm-combat" (click)="choice.confirmReorder()" [disabled]="choice.reorderAvailableCards.length > 0">Confirm Order</button>
        </div>
      </div>
    }

    @if (choice.choosingHandTopBottom) {
      <div class="combat-banner reorder-banner">
        <span>{{ choice.handTopBottomPrompt }}</span>
      </div>
      <div class="reorder-zone">
        @if (choice.handTopBottomAvailableCards.length > 0) {
          <div class="reorder-section">
            <div class="reorder-label">
              @if (choice.handTopBottomStep === 0) {
                Click a card to put into your hand:
              } @else {
                Click a card to put on top of your library:
              }
            </div>
            <div class="reorder-cards">
              @for (item of choice.handTopBottomAvailableCards; track item.originalIndex) {
                <app-card-display
                  [card]="item.card"
                  class="reorder-card available"
                  (click)="choice.selectHandTopBottomCard(item.originalIndex)"
                  (mouseenter)="onCardHover(item.card)"
                  (mouseleave)="onCardHoverEnd()" />
              }
            </div>
          </div>
        }
        @if (choice.handTopBottomHandIndex !== null) {
          <div class="reorder-section">
            <div class="reorder-label">Hand:</div>
            <div class="reorder-cards">
              <div class="reorder-card-wrapper">
                <div class="reorder-position-badge">H</div>
                <app-card-display
                  [card]="choice.handTopBottomCards[choice.handTopBottomHandIndex]"
                  class="reorder-card placed"
                  (mouseenter)="onCardHover(choice.handTopBottomCards[choice.handTopBottomHandIndex])"
                  (mouseleave)="onCardHoverEnd()" />
              </div>
            </div>
          </div>
        }
        @if (choice.handTopBottomTopIndex !== null) {
          <div class="reorder-section">
            <div class="reorder-label">Top of library:</div>
            <div class="reorder-cards">
              <div class="reorder-card-wrapper">
                <div class="reorder-position-badge">T</div>
                <app-card-display
                  [card]="choice.handTopBottomCards[choice.handTopBottomTopIndex]"
                  class="reorder-card placed"
                  (mouseenter)="onCardHover(choice.handTopBottomCards[choice.handTopBottomTopIndex])"
                  (mouseleave)="onCardHoverEnd()" />
              </div>
            </div>
          </div>
        }
        @if (choice.handTopBottomStep === 2 && choice.handTopBottomAvailableCards.length > 0) {
          <div class="reorder-section">
            <div class="reorder-label">Bottom of library:</div>
            <div class="reorder-cards">
              @for (item of choice.handTopBottomAvailableCards; track item.originalIndex) {
                <div class="reorder-card-wrapper">
                  <div class="reorder-position-badge">B</div>
                  <app-card-display
                    [card]="item.card"
                    class="reorder-card placed"
                    (mouseenter)="onCardHover(item.card)"
                    (mouseleave)="onCardHoverEnd()" />
                </div>
              }
            </div>
          </div>
        }
        <div class="reorder-actions">
          <button class="btn-confirm-combat" (click)="choice.undoHandTopBottom()" [disabled]="choice.handTopBottomHandIndex === null">Undo</button>
          <button class="btn-confirm-combat" (click)="choice.confirmHandTopBottom()" [disabled]="choice.handTopBottomStep !== 2">Confirm</button>
        </div>
      </div>
    }

    @if (choice.searchingLibrary) {
      <div class="reveal-hand-overlay">
        <div class="reveal-hand-card">
          <h2>{{ choice.librarySearchPrompt }}</h2>
          <div class="reveal-hand-cards">
            @for (card of choice.librarySearchCards; track $index) {
              <app-card-display [card]="card"
                class="library-search-card"
                (click)="choice.chooseLibraryCard($index)"
                (mouseenter)="onCardHover(card)"
                (mouseleave)="onCardHoverEnd()" />
            }
          </div>
          @if (choice.librarySearchCanFailToFind) {
            <button class="btn-keep" (click)="choice.declineLibrarySearch()">Decline</button>
          }
        </div>
      </div>
    }

    @if (choice.choosingXValue) {
      <div class="combat-banner targeting-banner">
        <span>Choose X value for {{ choice.xValueCardName }} (max {{ choice.xValueMaximum }}):</span>
        <input type="number" [min]="0" [max]="choice.xValueMaximum" [(ngModel)]="choice.xValueInput" class="x-value-input" />
        <button class="btn-confirm-combat" (click)="choice.confirmXValue()" [disabled]="choice.xValueInput < 0 || choice.xValueInput > choice.xValueMaximum">Confirm</button>
        <button class="btn-confirm-combat" (click)="choice.cancelXValue()">Cancel</button>
      </div>
    }

    @if (choice.distributingDamage) {
      <div class="combat-banner targeting-banner">
        <span>Click attacking creatures to assign damage for {{ choice.damageDistributionCardName }} ({{ choice.damageDistributionRemaining }} remaining of {{ choice.damageDistributionXValue }})</span>
        <button class="btn-confirm-combat" (click)="choice.confirmDamageDistribution()" [disabled]="choice.damageDistributionRemaining !== 0">Confirm</button>
        <button class="btn-confirm-combat" (click)="choice.cancelDamageDistribution()">Cancel</button>
      </div>
    }

    <div class="battlefield-area">
      <div class="battlefield-row">
        <div class="battlefield-label">{{ game()?.playerNames?.[opponentPlayerIndex] }}'s Battlefield</div>
        <div class="battlefield-sub-row lands-row">
          @for (item of opponentLandStacks; track $index) {
            @if (isLandStack(item)) {
              <div class="land-stack" [attr.data-stack-size]="item.lands.length">
                @for (ip of item.lands; track ip.originalIndex) {
                  <div class="land-stack-item">
                    <div class="permanent-stack">
                      @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                        <app-card-display
                          [card]="aura.perm.card"
                          [permanent]="aura.perm"
                          class="attached-aura"
                          [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                          (click)="onAuraClick(aura)"
                          (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                          (mouseleave)="onCardHoverEnd()" />
                      }
                      <app-card-display
                        [card]="ip.perm.card"
                        [permanent]="ip.perm"
                        [class.tapped]="ip.perm.tapped"
                        [class.targetable]="choice.targeting && choice.isValidTarget(ip.perm)"
                        [class.stack-targeted]="stackTargetId() === ip.perm.id"
                        [class.choosable-permanent]="(choice.choosingPermanent && choice.choosablePermanentIds().has(ip.perm.id)) || (choice.choosingMultiplePermanents && choice.multiPermanentChoiceIds().has(ip.perm.id))"
                        [class.selected-multi-permanent]="choice.choosingMultiplePermanents && choice.multiPermanentSelectedIds().has(ip.perm.id)"
                        (click)="onOpponentBattlefieldCardClick(ip.originalIndex)"
                        (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                        (mouseleave)="onCardHoverEnd()" />
                    </div>
                  </div>
                }
              </div>
            } @else {
              <div class="permanent-stack">
                @for (aura of getAttachedAuras(item.perm.id); track aura.perm.id) {
                  <app-card-display
                    [card]="aura.perm.card"
                    [permanent]="aura.perm"
                    class="attached-aura"
                    [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                    (click)="onAuraClick(aura)"
                    (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                    (mouseleave)="onCardHoverEnd()" />
                }
                <app-card-display
                  [card]="item.perm.card"
                  [permanent]="item.perm"
                  [class.tapped]="item.perm.tapped"
                  [class.targetable]="choice.targeting && choice.isValidTarget(item.perm)"
                  [class.stack-targeted]="stackTargetId() === item.perm.id"
                  [class.choosable-permanent]="(choice.choosingPermanent && choice.choosablePermanentIds().has(item.perm.id)) || (choice.choosingMultiplePermanents && choice.multiPermanentChoiceIds().has(item.perm.id))"
                  [class.selected-multi-permanent]="choice.choosingMultiplePermanents && choice.multiPermanentSelectedIds().has(item.perm.id)"
                  (click)="onOpponentBattlefieldCardClick(item.originalIndex)"
                  (mouseenter)="onCardHover(item.perm.card, item.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              </div>
            }
          }
        </div>
        <div class="battlefield-sub-row creatures-row">
          @for (ip of opponentCreaturesNotInCombat(); track ip.originalIndex) {
            <div class="permanent-stack">
              @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                <app-card-display
                  [card]="aura.perm.card"
                  [permanent]="aura.perm"
                  class="attached-aura"
                  [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                  (click)="onAuraClick(aura)"
                  (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              }
              <app-card-display
                [card]="ip.perm.card"
                [permanent]="ip.perm"
                [class.tapped]="ip.perm.tapped"
                [class.summoning-sick]="ip.perm.summoningSick"
                [class.block-target]="isBlockTarget(ip.originalIndex)"
                [class.targetable]="choice.targeting && choice.isValidTarget(ip.perm)"
                [class.stack-targeted]="stackTargetId() === ip.perm.id"
                [class.choosable-permanent]="(choice.choosingPermanent && choice.choosablePermanentIds().has(ip.perm.id)) || (choice.choosingMultiplePermanents && choice.multiPermanentChoiceIds().has(ip.perm.id))"
                [class.selected-multi-permanent]="choice.choosingMultiplePermanents && choice.multiPermanentSelectedIds().has(ip.perm.id)"
                (click)="onOpponentBattlefieldCardClick(ip.originalIndex)"
                (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                (mouseleave)="onCardHoverEnd()" />
            </div>
          }
        </div>
        @if (opponentBattlefield.length === 0) {
          <div class="battlefield-empty">No permanents</div>
        }
        @if (opponentHand.length > 0) {
          <div class="revealed-hand-row">
            <div class="revealed-hand-label">Revealed Hand ({{ opponentHand.length }})</div>
            <div class="revealed-hand-cards">
              @for (card of opponentHand; track $index) {
                <app-card-display [card]="card" class="revealed-hand-card" (mouseenter)="onCardHover(card)" (mouseleave)="onCardHoverEnd()" />
              }
            </div>
          </div>
        }
      </div>

      @if (showCombatZone) {
        <div class="combat-zone">
          <div class="combat-zone-label">Combat</div>
          <div class="combat-groups">
            @for (group of combatPairings; track group.attackerIndex) {
              <div class="combat-group">
                <div class="combat-attacker-slot">
                  <div class="permanent-stack">
                    @for (aura of getAttachedAuras(group.attacker.id); track aura.perm.id) {
                      <app-card-display
                        [card]="aura.perm.card"
                        [permanent]="aura.perm"
                        class="attached-aura"
                        [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                        (click)="onAuraClick(aura)"
                        (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                        (mouseleave)="onCardHoverEnd()" />
                    }
                    <app-card-display
                      [card]="group.attacker.card"
                      [permanent]="group.attacker"
                      [class.attacking]="group.attacker.attacking"
                      [class.selected-attacker]="declaringAttackers && isSelectedAttacker(group.attackerIndex)"
                      [class.block-target]="declaringBlockers && selectedBlockerIndex !== null && !group.attackerIsMine"
                      [class.targetable]="choice.distributingDamage || (choice.targeting && choice.isValidTarget(group.attacker))"
                      [class.stack-targeted]="stackTargetId() === group.attacker.id"
                      (click)="onCombatAttackerClick(group)"
                      (contextmenu)="$event.preventDefault(); choice.unassignDamage(group.attacker.id)"
                      (mouseenter)="onCardHover(group.attacker.card, group.attacker)"
                      (mouseleave)="onCardHoverEnd()">
                      <div class="card-combat-badge attacking-badge">Attacking</div>
                      @if (choice.distributingDamage && choice.getDamageAssigned(group.attacker.id) > 0) {
                        <div class="card-combat-badge damage-badge">{{ choice.getDamageAssigned(group.attacker.id) }} dmg</div>
                      }
                    </app-card-display>
                  </div>
                </div>
                @if (group.blockers.length > 0) {
                  <div class="combat-blocker-slots">
                    @for (blocker of group.blockers; track blocker.index) {
                      <div class="permanent-stack">
                        @for (aura of getAttachedAuras(blocker.perm.id); track aura.perm.id) {
                          <app-card-display
                            [card]="aura.perm.card"
                            [permanent]="aura.perm"
                            class="attached-aura"
                            [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                            (click)="onAuraClick(aura)"
                            (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                            (mouseleave)="onCardHoverEnd()" />
                        }
                        <app-card-display
                          [card]="blocker.perm.card"
                          [permanent]="blocker.perm"
                          class="blocking"
                          [class.stack-targeted]="stackTargetId() === blocker.perm.id"
                          (click)="onCombatBlockerClick(blocker)"
                          (mouseenter)="onCardHover(blocker.perm.card, blocker.perm)"
                          (mouseleave)="onCardHoverEnd()">
                          <div class="card-combat-badge blocking-badge">Blocking</div>
                        </app-card-display>
                      </div>
                    }
                  </div>
                }
              </div>
            }
          </div>
        </div>
      } @else {
        <div class="battlefield-divider"></div>
      }

      <div class="battlefield-row">
        <div class="battlefield-label">Your Battlefield</div>
        <div class="battlefield-sub-row creatures-row">
          @for (ip of myCreaturesNotInCombat(); track ip.originalIndex) {
            <div class="permanent-stack">
              @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                <app-card-display
                  [card]="aura.perm.card"
                  [permanent]="aura.perm"
                  class="attached-aura"
                  [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                  (click)="onAuraClick(aura)"
                  (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              }
              <app-card-display
                [card]="ip.perm.card"
                [permanent]="ip.perm"
                [class.tapped]="ip.perm.tapped"
                [class.tappable]="choice.canTapPermanent(ip.originalIndex) && !declaringAttackers && !declaringBlockers"
                [class.summoning-sick]="ip.perm.summoningSick"
                [class.can-attack]="canAttack(ip.originalIndex) && !isSelectedAttacker(ip.originalIndex)"
                [class.must-attack]="mustAttackIndices().has(ip.originalIndex)"
                [class.can-block]="canBlock(ip.originalIndex) && !isAssignedBlocker(ip.originalIndex) && selectedBlockerIndex !== ip.originalIndex"
                [class.selected-blocker]="selectedBlockerIndex === ip.originalIndex"
                [class.assigned-blocker]="isAssignedBlocker(ip.originalIndex)"
                [class.targetable]="choice.targeting && choice.isValidTarget(ip.perm)"
                [class.stack-targeted]="stackTargetId() === ip.perm.id"
                [class.choosable-permanent]="(choice.choosingPermanent && choice.choosablePermanentIds().has(ip.perm.id)) || (choice.choosingMultiplePermanents && choice.multiPermanentChoiceIds().has(ip.perm.id))"
                [class.selected-multi-permanent]="choice.choosingMultiplePermanents && choice.multiPermanentSelectedIds().has(ip.perm.id)"
                (click)="onMyBattlefieldCardClick(ip.originalIndex)"
                (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                (mouseleave)="onCardHoverEnd()" />
            </div>
          }
        </div>
        <div class="battlefield-sub-row lands-row">
          @for (item of myLandStacks; track $index) {
            @if (isLandStack(item)) {
              <div class="land-stack" [attr.data-stack-size]="item.lands.length">
                @for (ip of item.lands; track ip.originalIndex) {
                  <div class="land-stack-item">
                    <div class="permanent-stack">
                      @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                        <app-card-display
                          [card]="aura.perm.card"
                          [permanent]="aura.perm"
                          class="attached-aura"
                          [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                          (click)="onAuraClick(aura)"
                          (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                          (mouseleave)="onCardHoverEnd()" />
                      }
                      <app-card-display
                        [card]="ip.perm.card"
                        [permanent]="ip.perm"
                        [class.tapped]="ip.perm.tapped"
                        [class.tappable]="choice.canTapPermanent(ip.originalIndex) && !declaringAttackers && !declaringBlockers"
                        [class.targetable]="choice.targeting && choice.isValidTarget(ip.perm)"
                        [class.stack-targeted]="stackTargetId() === ip.perm.id"
                        [class.choosable-permanent]="(choice.choosingPermanent && choice.choosablePermanentIds().has(ip.perm.id)) || (choice.choosingMultiplePermanents && choice.multiPermanentChoiceIds().has(ip.perm.id))"
                        [class.selected-multi-permanent]="choice.choosingMultiplePermanents && choice.multiPermanentSelectedIds().has(ip.perm.id)"
                        (click)="onMyBattlefieldCardClick(ip.originalIndex)"
                        (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                        (mouseleave)="onCardHoverEnd()" />
                    </div>
                  </div>
                }
              </div>
            } @else {
              <div class="permanent-stack">
                @for (aura of getAttachedAuras(item.perm.id); track aura.perm.id) {
                  <app-card-display
                    [card]="aura.perm.card"
                    [permanent]="aura.perm"
                    class="attached-aura"
                    [class.targetable]="choice.targeting && choice.isValidTarget(aura.perm)"
                    (click)="onAuraClick(aura)"
                    (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                    (mouseleave)="onCardHoverEnd()" />
                }
                <app-card-display
                  [card]="item.perm.card"
                  [permanent]="item.perm"
                  [class.tapped]="item.perm.tapped"
                  [class.tappable]="choice.canTapPermanent(item.originalIndex) && !declaringAttackers && !declaringBlockers"
                  [class.targetable]="choice.targeting && choice.isValidTarget(item.perm)"
                  [class.stack-targeted]="stackTargetId() === item.perm.id"
                  [class.choosable-permanent]="(choice.choosingPermanent && choice.choosablePermanentIds().has(item.perm.id)) || (choice.choosingMultiplePermanents && choice.multiPermanentChoiceIds().has(item.perm.id))"
                  [class.selected-multi-permanent]="choice.choosingMultiplePermanents && choice.multiPermanentSelectedIds().has(item.perm.id)"
                  (click)="onMyBattlefieldCardClick(item.originalIndex)"
                  (mouseenter)="onCardHover(item.perm.card, item.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              </div>
            }
          }
        </div>
        @if (myBattlefield.length === 0) {
          <div class="battlefield-empty">No permanents</div>
        }
      </div>
    </div>

    <div class="phase-tracker">
      @for (group of phaseGroups; track group.phaseName) {
        <div class="phase-group">
          <div class="phase-label">{{ group.phaseName }}</div>
          <div class="phase-steps">
            @for (stepInfo of group.steps; track stepInfo.step) {
              <div class="step-pip"
                   [class.active]="game()?.currentStep === stepInfo.step"
                   [class.auto-stop]="isAutoStop(stepInfo.step)"
                   [class.force-stop]="isForceStop(stepInfo.step)"
                   [title]="stepInfo.displayName"
                   (click)="toggleAutoStop(stepInfo.step)">
                {{ stepInfo.displayName }}
              </div>
            }
          </div>
        </div>
      }
    </div>

    @if (totalMana > 0) {
      <div class="mana-pool-bar">
        <div class="mana-pool">
          @for (entry of manaEntries; track entry.color) {
            <div class="mana-pip" [attr.data-color]="entry.color">
              <span class="mana-count">{{ entry.count }}</span>
            </div>
          }
        </div>
      </div>
    }

    @if (choice.choosingFromHand) {
      <div class="combat-banner hand-choice-banner">
        <span>{{ choice.handChoicePrompt }}</span>
        <button class="btn-confirm-combat" (click)="choice.declineHandChoice()">Decline</button>
      </div>
    }

    @if (choice.choosingColor) {
      <div class="combat-banner color-choice-banner">
        <span>{{ choice.colorChoicePrompt }}</span>
        <div class="color-choice-buttons">
          @for (color of choice.colorChoices; track color) {
            <button class="btn-color-choice" [attr.data-color]="color" (click)="choice.chooseColor(color)">{{ choice.getColorDisplayName(color) }}</button>
          }
        </div>
      </div>
    }

    @if (choice.choosingAbility) {
      <div class="combat-banner ability-choice-banner">
        <span>Choose an ability to activate:</span>
        <div class="ability-choice-buttons">
          @for (ch of choice.abilityChoices; track ch.index) {
            <button class="btn-confirm-combat" [disabled]="!ch.usable" (click)="choice.chooseAbility(ch)">{{ ch.ability.description }}</button>
          }
        </div>
        <button class="btn-confirm-combat" (click)="choice.cancelAbilityChoice()">Cancel</button>
      </div>
    }

    @if (choice.choosingPermanent) {
      <div class="combat-banner permanent-choice-banner">
        <span>{{ choice.permanentChoicePrompt }}</span>
      </div>
    }

    @if (choice.choosingMultiplePermanents) {
      <div class="combat-banner permanent-choice-banner">
        <span>{{ choice.multiPermanentChoicePrompt }} ({{ choice.multiPermanentSelectedIds().size }}/{{ choice.multiPermanentMaxCount }} selected)</span>
        <button class="btn-confirm-combat" (click)="choice.confirmMultiPermanentChoice()">Confirm</button>
      </div>
    }

    @if (choice.choosingGraveyardCards) {
      <div class="combat-banner permanent-choice-banner">
        <span>{{ choice.multiGraveyardPrompt }} ({{ choice.graveyardChoiceSelectedIds().size }}/{{ choice.graveyardChoiceMaxCount }} selected)</span>
        <button class="btn-confirm-combat" (click)="choice.confirmGraveyardCardChoice()">Confirm</button>
      </div>
      <div class="graveyard-choice-overlay">
        <div class="graveyard-choice-cards">
          @for (card of choice.multiGraveyardCards; track $index) {
            <app-card-display
              [card]="card"
              class="graveyard-choice-card"
              [class.selected-graveyard-card]="choice.graveyardChoiceSelectedIds().has(choice.graveyardChoiceCardIds[$index])"
              (click)="choice.toggleGraveyardCardSelection($index)"
              (mouseenter)="onCardHover(card)"
              (mouseleave)="onCardHoverEnd()" />
          }
        </div>
      </div>
    }

    <div class="hand-area">
      <div class="hand-label">Your Hand ({{ hand.length }} cards)</div>
      <div class="hand-cards">
        @for (card of hand; track $index) {
          <app-card-display
            [card]="card"
            [class.playable]="isCardPlayable($index)"
            [class.choosable-card]="choice.choosingFromHand && choice.isChoosableCard($index)"
            (click)="choice.choosingFromHand ? choice.chooseCardFromHand($index) : playCard($index)"
            (mouseenter)="onCardHover(card)"
            (mouseleave)="onCardHoverEnd()" />
        }
      </div>
    </div>
  }

  @if (gameOverWinner) {
    <div class="game-over-overlay">
      <div class="game-over-card">
        <h2>Game Over</h2>
        <p class="winner-text">{{ gameOverWinner }} wins!</p>
        <button class="btn-keep" (click)="backToLobby()">Back to Lobby</button>
      </div>
    </div>
  }

  @if (choice.choosingFromGraveyard) {
    <div class="reveal-hand-overlay">
      <div class="reveal-hand-card">
        <h2>{{ choice.graveyardChoicePrompt }}</h2>
        <div class="reveal-hand-cards">
          @for (entry of choice.graveyardChoiceCards; track entry.index) {
            <div class="graveyard-choice-entry">
              <app-card-display [card]="entry.card"
                class="choosable-card"
                (click)="choice.chooseGraveyardCard(entry.index)"
                (mouseenter)="onCardHover(entry.card)"
                (mouseleave)="onCardHoverEnd()" />
              <div class="graveyard-choice-owner">{{ entry.owner }}</div>
            </div>
          }
        </div>
      </div>
    </div>
  }

  @if (choice.revealingHand) {
    <div class="reveal-hand-overlay">
      <div class="reveal-hand-card">
        @if (choice.choosingFromRevealedHand) {
          <h2>{{ choice.revealedHandChoicePrompt }}</h2>
        } @else {
          <h2>{{ choice.revealedHandPlayerName }}'s Hand</h2>
        }
        @if (choice.revealedHandCards.length === 0) {
          <p class="reveal-hand-empty">Hand is empty.</p>
        } @else {
          <div class="reveal-hand-cards">
            @for (card of choice.revealedHandCards; track $index) {
              <app-card-display [card]="card"
                [class.choosable-card]="choice.isRevealedHandCardChoosable($index)"
                (click)="choice.choosingFromRevealedHand ? choice.chooseFromRevealedHand($index) : null"
                (mouseenter)="onCardHover(card)"
                (mouseleave)="onCardHoverEnd()" />
            }
          </div>
        }
        @if (!choice.choosingFromRevealedHand) {
          <button class="btn-keep" (click)="choice.closeRevealHand()">Close</button>
        }
      </div>
    </div>
  }

  @if (game()?.status === GameStatus.WAITING) {
    <div class="players-area">
      <div class="game-title">{{ game()?.gameName }}</div>
      <div class="player-card">
        <div class="player-label">Player 1</div>
        <div class="player-name">{{ player1Name }}</div>
      </div>

      <div class="vs-divider">VS</div>

      <div class="player-card">
        <div class="player-label">Player 2</div>
        @if (isWaitingForOpponent) {
          <div class="player-name waiting">Waiting for an opponent</div>
        } @else {
          <div class="player-name">{{ player2Name }}</div>
        }
      </div>
    </div>
  }
    </div>

    <div class="side-panel">
      <div class="tab-header">
        <div class="tab" [class.active]="activeTab() === 'game'" (click)="activeTab.set('game')">Game</div>
        <div class="tab" [class.active]="activeTab() === 'stack'" (click)="activeTab.set('stack')">
          Stack
          @if (!isStackEmpty) {
            <span class="tab-badge">{{ stackEntries.length }}</span>
          }
        </div>
        <div class="tab" [class.active]="activeTab() === 'graveyard'" (click)="activeTab.set('graveyard')">
          Graveyard
          @if (myGraveyard.length + opponentGraveyard.length > 0) {
            <span class="tab-badge">{{ myGraveyard.length + opponentGraveyard.length }}</span>
          }
        </div>
      </div>

      <div class="tab-content">
        @if (activeTab() === 'game') {
          <div class="game-tab">
            <div class="card-preview-panel">
              @if (hoveredCard()) {
                <app-card-display [card]="hoveredCard()!" [permanent]="hoveredPermanent()" [preview]="true" class="preview-card" />
              } @else {
                <div class="card-preview-empty"></div>
              }
            </div>

            <div class="turn-info">
              <div class="player-badge" [class.active]="isActivePlayer(0)" [class.inactive]="!isActivePlayer(0)" [class.has-priority]="holdsPriority(0)" [class.targetable]="choice.targetingForPlayer || (choice.multiTargeting && choice.multiTargetForPlayer)" [class.multi-target-selected]="choice.multiTargeting && choice.multiTargetForPlayer && choice.isMultiTargetSelected(getPlayerId(0))" [class.stack-targeted]="isStackTargetPlayer(0)" [class.choosable-permanent]="choice.choosingPermanent && choice.choosablePermanentIds().has(getPlayerId(0))" (click)="onPlayerBadgeClick(0)">
                {{ player1Name }}
                <span class="life-total">Life: {{ getLifeTotal(0) }}</span>
                <span class="hand-size">Hand: {{ player1HandSize }}</span>
                <span class="deck-size">Deck: {{ player1DeckSize }}</span>
                @if (holdsPriority(0)) {
                  <span class="priority-indicator">Priority</span>
                }
              </div>
              <div class="turn-center">
                <span class="turn-number">Turn {{ game()?.turnNumber }}</span>
                <span class="vs-label">VS</span>
              </div>
              <div class="player-badge" [class.active]="isActivePlayer(1)" [class.inactive]="!isActivePlayer(1)" [class.has-priority]="holdsPriority(1)" [class.targetable]="choice.targetingForPlayer || (choice.multiTargeting && choice.multiTargetForPlayer)" [class.multi-target-selected]="choice.multiTargeting && choice.multiTargetForPlayer && choice.isMultiTargetSelected(getPlayerId(1))" [class.stack-targeted]="isStackTargetPlayer(1)" [class.choosable-permanent]="choice.choosingPermanent && choice.choosablePermanentIds().has(getPlayerId(1))" (click)="onPlayerBadgeClick(1)">
                {{ player2Name }}
                <span class="life-total">Life: {{ getLifeTotal(1) }}</span>
                <span class="hand-size">Hand: {{ player2HandSize }}</span>
                <span class="deck-size">Deck: {{ player2DeckSize }}</span>
                @if (holdsPriority(1)) {
                  <span class="priority-indicator">Priority</span>
                }
              </div>
            </div>

            <div class="log-entries">
              @if (gameLog.length === 0) {
                <div class="log-entry empty">Waiting for game to start...</div>
              } @else {
                @for (entry of gameLog; track $index) {
                  <div class="log-entry">{{ entry }}</div>
                }
              }
            </div>
          </div>
        } @else if (activeTab() === 'stack') {
          <div class="stack-entries">
            @if (isStackEmpty) {
              <div class="log-entry empty">The stack is empty.</div>
            } @else {
              @for (entry of stackEntries; track $index) {
                <div class="stack-entry-wrapper"
                     [class.spell-targetable]="choice.targetingSpell && entry.isSpell"
                     [class.stack-targeted]="isStackTargetSpell(entry)"
                     [class.choosable-permanent]="choice.choosingPermanent && choice.choosablePermanentIds().has(entry.cardId)"
                     (click)="choice.choosingPermanent && choice.choosablePermanentIds().has(entry.cardId) ? choice.choosePermanent(entry.cardId) : (choice.targetingSpell && entry.isSpell ? choice.selectSpellTarget(entry) : null)"
                     (mouseenter)="onStackEntryHover(entry); onCardHover(entry.card)"
                     (mouseleave)="onStackEntryHoverEnd(); onCardHoverEnd()">
                  <app-card-display
                    [card]="entry.card"
                    [attr.data-entry-type]="entry.entryType" />
                  <div class="stack-entry-overlay">
                    <div class="stack-entry-controller">
                      ({{ getPlayerName(entry.controllerId) }})
                    </div>
                    @if (entry.targetPermanentId) {
                      <div class="stack-entry-target">
                        Target: {{ getStackEntryTargetName(entry) ?? entry.targetPermanentId }}
                      </div>
                    }
                  </div>
                  @if ($index === 0) {
                    <div class="stack-top-badge">Next to resolve</div>
                  }
                </div>
              }
            }
          </div>
        } @else {
          <div class="graveyard-tab">
            <div class="graveyard-section">
              <div class="graveyard-section-label">{{ game()?.playerNames?.[opponentPlayerIndex] }}'s Graveyard ({{ opponentGraveyard.length }})</div>
              @if (opponentGraveyard.length === 0) {
                <div class="log-entry empty">No cards in graveyard.</div>
              } @else {
                <div class="graveyard-tab-cards">
                  @for (card of opponentGraveyard; track $index) {
                    <app-card-display [card]="card" class="graveyard-card"
                      (mouseenter)="onCardHover(card)" (mouseleave)="onCardHoverEnd()" />
                  }
                </div>
              }
            </div>
            <div class="graveyard-section">
              <div class="graveyard-section-label">Your Graveyard ({{ myGraveyard.length }})</div>
              @if (myGraveyard.length === 0) {
                <div class="log-entry empty">No cards in graveyard.</div>
              } @else {
                <div class="graveyard-tab-cards">
                  @for (card of myGraveyard; track $index) {
                    <app-card-display [card]="card" class="graveyard-card"
                      [class.playable]="isGraveyardLandPlayable($index)"
                      (click)="playGraveyardLand($index)"
                      (mouseenter)="onCardHover(card)" (mouseleave)="onCardHoverEnd()" />
                  }
                </div>
              }
            </div>
          </div>
        }
      </div>

      <div class="action-bar">
        @if (declaringAttackers) {
          <button class="btn-pass btn-pass-orange" (click)="confirmAttackers()">Confirm Attackers</button>
        } @else if (declaringBlockers) {
          <button class="btn-pass btn-pass-blue" (click)="confirmBlockers()">Confirm Blockers</button>
        } @else {
          <button class="btn-pass" (click)="passPriority()" [disabled]="!hasPriority">Pass Priority</button>
        }
      </div>

      @if (choice.awaitingMayAbility) {
        <div class="combat-banner may-ability-banner">
          <span>{{ choice.mayAbilityPrompt }}</span>
          <button class="btn-confirm-combat" (click)="choice.acceptMayAbility()">Yes</button>
          <button class="btn-confirm-combat" (click)="choice.declineMayAbility()">No</button>
        </div>
      }
    </div>
  </div>
</div>
