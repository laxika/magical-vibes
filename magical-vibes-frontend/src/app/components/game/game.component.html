<div class="game-container">
  <div class="game-layout">
    <div class="game-area">
  @if (game()?.status === GameStatus.MULLIGAN) {
    <div class="mulligan-section">
      <div class="turn-info">
        <div class="player-badge active">
          {{ player1Name }}
          <span class="deck-size">Deck: {{ player1DeckSize }}</span>
        </div>
        <div class="turn-center">
          <span class="turn-number">Mulligan Phase</span>
          <span class="vs-label">VS</span>
        </div>
        <div class="player-badge active">
          {{ player2Name }}
          <span class="deck-size">Deck: {{ player2DeckSize }}</span>
        </div>
      </div>

      @if (selectingBottomCards) {
        <div class="hand-area bottom-selection">
          <div class="hand-label">Select {{ bottomCardCount }} card{{ bottomCardCount > 1 ? 's' : '' }} to put on the bottom of your library</div>
          <div class="selection-count">Selected: {{ selectedCardIndices.size }} / {{ bottomCardCount }}</div>
          <div class="hand-cards">
            @for (card of hand; track $index) {
              <app-card-display
                [card]="card"
                class="selectable"
                [class.selected]="isCardSelected($index)"
                (click)="toggleCardSelection($index)"
                (mouseenter)="onCardHover(card)"
                (mouseleave)="onCardHoverEnd()">
                @if (isCardSelected($index)) {
                  <div class="card-selected-badge">Bottom</div>
                }
              </app-card-display>
            }
          </div>
          <div class="mulligan-actions">
            <button class="btn-keep" (click)="confirmBottomCards()" [disabled]="!canConfirmBottom">Confirm Selection</button>
          </div>
        </div>
      } @else {
        <div class="hand-area">
          <div class="hand-label">Your Hand ({{ hand.length }} cards)</div>
          <div class="hand-cards">
            @for (card of hand; track $index) {
              <app-card-display [card]="card" (mouseenter)="onCardHover(card)" (mouseleave)="onCardHoverEnd()" />
            }
          </div>
        </div>

        <div class="mulligan-info">
          @if ((game()?.mulliganCount ?? 0) > 0) {
            <span class="mulligan-count">Mulligan count: {{ game()?.mulliganCount }}</span>
          }
        </div>

        @if (!selfKept) {
          <div class="mulligan-actions">
            <button class="btn-keep" (click)="keepHand()">Keep Hand</button>
            <button class="btn-mulligan" (click)="takeMulligan()" [disabled]="!canMulligan">Mulligan</button>
          </div>
        } @else {
          <div class="mulligan-actions">
            <span class="kept-label">You kept your hand.</span>
          </div>
        }
      }

      <div class="opponent-mulligan-status">
        @if (opponentKept) {
          <span>Opponent kept their hand.</span>
        } @else {
          <span>Opponent is deciding...</span>
        }
      </div>
    </div>
  }

  @if (game()?.status === GameStatus.RUNNING || game()?.status === GameStatus.FINISHED) {
    @if (!isStackEmpty) {
      <div class="stack-zone">
        <div class="stack-label">The Stack</div>
        <div class="stack-entries">
          @for (entry of stackEntries; track $index) {
            <div class="stack-entry-wrapper"
                 [class.spell-targetable]="targetingSpell && entry.isSpell"
                 [class.stack-targeted]="isStackTargetSpell(entry)"
                 (click)="targetingSpell && entry.isSpell ? selectSpellTarget(entry) : null"
                 (mouseenter)="onStackEntryHover(entry); onCardHover(entry.card)"
                 (mouseleave)="onStackEntryHoverEnd(); onCardHoverEnd()">
              <app-card-display
                [card]="entry.card"
                [attr.data-entry-type]="entry.entryType" />
              <div class="stack-entry-overlay">
                <div class="stack-entry-controller">
                  ({{ getPlayerName(entry.controllerId) }})
                </div>
                @if (entry.targetPermanentId) {
                  <div class="stack-entry-target">
                    Target: {{ getStackEntryTargetName(entry) ?? entry.targetPermanentId }}
                  </div>
                }
              </div>
              @if ($index === 0) {
                <div class="stack-top-badge">Next to resolve</div>
              }
            </div>
          }
        </div>
      </div>
    }

    @if (declaringAttackers) {
      <div class="combat-banner attackers-banner">
        <span>Declare Attackers — select creatures to attack, then confirm</span>
        <button class="btn-confirm-combat" (click)="confirmAttackers()">Confirm Attackers</button>
      </div>
    }

    @if (declaringBlockers) {
      <div class="combat-banner blockers-banner">
        <span>Assign Blockers — click your creature, then click an attacking creature to block it</span>
        <div class="combat-banner-actions">
          @if (selectedBlockerIndex !== null) {
            <button class="btn-confirm-combat" (click)="cancelBlockerSelection()">Cancel Selection</button>
          }
          <button class="btn-confirm-combat" (click)="confirmBlockers()">Confirm Blockers</button>
        </div>
      </div>
    }

    @if (targeting) {
      <div class="combat-banner targeting-banner">
        @if (targetingForPlayer) {
          <span>Select a target player for {{ targetingCardName }}</span>
        } @else if (targetingAllowedTypes.includes('Enchantment')) {
          <span>Select a target Aura for {{ targetingCardName }}</span>
        } @else if (targetingRequiresAttacking) {
          <span>Select a target attacking creature for {{ targetingCardName }}</span>
        } @else {
          <span>Select a target creature for {{ targetingCardName }}</span>
        }
        <button class="btn-confirm-combat" (click)="cancelTargeting()">Cancel</button>
      </div>
    }

    @if (targetingSpell) {
      <div class="combat-banner spell-targeting-banner">
        <span>Select a spell on the stack to counter with {{ targetingSpellCardName }}</span>
        <button class="btn-confirm-combat" (click)="cancelSpellTargeting()">Cancel</button>
      </div>
    }

    @if (reorderingLibrary) {
      <div class="combat-banner reorder-banner">
        <span>{{ reorderPrompt }}</span>
      </div>
      <div class="reorder-zone">
        @if (reorderAvailableCards.length > 0) {
          <div class="reorder-section">
            <div class="reorder-label">Click cards to set their order (top to bottom):</div>
            <div class="reorder-cards">
              @for (item of reorderAvailableCards; track item.originalIndex) {
                <app-card-display
                  [card]="item.card"
                  class="reorder-card available"
                  (click)="selectReorderCard(item.originalIndex)"
                  (mouseenter)="onCardHover(item.card)"
                  (mouseleave)="onCardHoverEnd()" />
              }
            </div>
          </div>
        }
        @if (reorderPlacedCards.length > 0) {
          <div class="reorder-section">
            <div class="reorder-label">New order (top of library first):</div>
            <div class="reorder-cards">
              @for (item of reorderPlacedCards; track item.originalIndex) {
                <div class="reorder-card-wrapper">
                  <div class="reorder-position-badge">{{ item.position }}</div>
                  <app-card-display
                    [card]="item.card"
                    class="reorder-card placed"
                    (mouseenter)="onCardHover(item.card)"
                    (mouseleave)="onCardHoverEnd()" />
                </div>
              }
            </div>
          </div>
        }
        <div class="reorder-actions">
          <button class="btn-confirm-combat" (click)="undoLastReorderCard()" [disabled]="reorderOriginalIndices.length === 0">Undo</button>
          <button class="btn-confirm-combat" (click)="confirmReorder()" [disabled]="reorderAvailableCards.length > 0">Confirm Order</button>
        </div>
      </div>
    }

    @if (choosingXValue) {
      <div class="combat-banner targeting-banner">
        <span>Choose X value for {{ xValueCardName }} (max {{ xValueMaximum }}):</span>
        <input type="number" [min]="0" [max]="xValueMaximum" [(ngModel)]="xValueInput" class="x-value-input" />
        <button class="btn-confirm-combat" (click)="confirmXValue()" [disabled]="xValueInput < 0 || xValueInput > xValueMaximum">Confirm</button>
        <button class="btn-confirm-combat" (click)="cancelXValue()">Cancel</button>
      </div>
    }

    @if (distributingDamage) {
      <div class="combat-banner targeting-banner">
        <span>Click attacking creatures to assign damage for {{ damageDistributionCardName }} ({{ damageDistributionRemaining }} remaining of {{ damageDistributionXValue }})</span>
        <button class="btn-confirm-combat" (click)="confirmDamageDistribution()" [disabled]="damageDistributionRemaining !== 0">Confirm</button>
        <button class="btn-confirm-combat" (click)="cancelDamageDistribution()">Cancel</button>
      </div>
    }

    <div class="battlefield-area">
      <div class="battlefield-row">
        <div class="battlefield-label">{{ game()?.playerNames?.[opponentPlayerIndex] }}'s Battlefield</div>
        <div class="battlefield-sub-row lands-row">
          @for (item of opponentLandStacks; track $index) {
            @if (isLandStack(item)) {
              <div class="land-stack" [attr.data-stack-size]="item.lands.length">
                @for (ip of item.lands; track ip.originalIndex) {
                  <div class="land-stack-item">
                    <div class="permanent-stack">
                      @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                        <app-card-display
                          [card]="aura.perm.card"
                          [permanent]="aura.perm"
                          class="attached-aura"
                          [class.targetable]="targeting && isValidTarget(aura.perm)"
                          (click)="onAuraClick(aura)"
                          (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                          (mouseleave)="onCardHoverEnd()" />
                      }
                      <app-card-display
                        [card]="ip.perm.card"
                        [permanent]="ip.perm"
                        [class.tapped]="ip.perm.tapped"
                        [class.targetable]="targeting && isValidTarget(ip.perm)"
                        [class.stack-targeted]="stackTargetId() === ip.perm.id"
                        [class.choosable-permanent]="(choosingPermanent && choosablePermanentIds().has(ip.perm.id)) || (choosingMultiplePermanents && multiPermanentChoiceIds().has(ip.perm.id))"
                        [class.selected-multi-permanent]="choosingMultiplePermanents && multiPermanentSelectedIds().has(ip.perm.id)"
                        (click)="onOpponentBattlefieldCardClick(ip.originalIndex)"
                        (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                        (mouseleave)="onCardHoverEnd()" />
                    </div>
                  </div>
                }
              </div>
            } @else {
              <div class="permanent-stack">
                @for (aura of getAttachedAuras(item.perm.id); track aura.perm.id) {
                  <app-card-display
                    [card]="aura.perm.card"
                    [permanent]="aura.perm"
                    class="attached-aura"
                    [class.targetable]="targeting && isValidTarget(aura.perm)"
                    (click)="onAuraClick(aura)"
                    (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                    (mouseleave)="onCardHoverEnd()" />
                }
                <app-card-display
                  [card]="item.perm.card"
                  [permanent]="item.perm"
                  [class.tapped]="item.perm.tapped"
                  [class.targetable]="targeting && isValidTarget(item.perm)"
                  [class.stack-targeted]="stackTargetId() === item.perm.id"
                  [class.choosable-permanent]="(choosingPermanent && choosablePermanentIds().has(item.perm.id)) || (choosingMultiplePermanents && multiPermanentChoiceIds().has(item.perm.id))"
                  [class.selected-multi-permanent]="choosingMultiplePermanents && multiPermanentSelectedIds().has(item.perm.id)"
                  (click)="onOpponentBattlefieldCardClick(item.originalIndex)"
                  (mouseenter)="onCardHover(item.perm.card, item.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              </div>
            }
          }
        </div>
        <div class="battlefield-sub-row creatures-row">
          @for (ip of opponentCreaturesNotInCombat(); track ip.originalIndex) {
            <div class="permanent-stack">
              @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                <app-card-display
                  [card]="aura.perm.card"
                  [permanent]="aura.perm"
                  class="attached-aura"
                  [class.targetable]="targeting && isValidTarget(aura.perm)"
                  (click)="onAuraClick(aura)"
                  (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              }
              <app-card-display
                [card]="ip.perm.card"
                [permanent]="ip.perm"
                [class.tapped]="ip.perm.tapped"
                [class.summoning-sick]="ip.perm.summoningSick"
                [class.block-target]="isBlockTarget(ip.originalIndex)"
                [class.targetable]="targeting && isValidTarget(ip.perm)"
                [class.stack-targeted]="stackTargetId() === ip.perm.id"
                [class.choosable-permanent]="(choosingPermanent && choosablePermanentIds().has(ip.perm.id)) || (choosingMultiplePermanents && multiPermanentChoiceIds().has(ip.perm.id))"
                [class.selected-multi-permanent]="choosingMultiplePermanents && multiPermanentSelectedIds().has(ip.perm.id)"
                (click)="onOpponentBattlefieldCardClick(ip.originalIndex)"
                (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                (mouseleave)="onCardHoverEnd()" />
            </div>
          }
        </div>
        @if (opponentBattlefield.length === 0) {
          <div class="battlefield-empty">No permanents</div>
        }
        @if (opponentGraveyard.length > 0) {
          <div class="graveyard-row">
            <div class="graveyard-label">Graveyard ({{ opponentGraveyard.length }})</div>
            <div class="graveyard-cards">
              @for (card of opponentGraveyard; track $index) {
                <app-card-display [card]="card" class="graveyard-card" (mouseenter)="onCardHover(card)" (mouseleave)="onCardHoverEnd()" />
              }
            </div>
          </div>
        }
      </div>

      @if (showCombatZone) {
        <div class="combat-zone">
          <div class="combat-zone-label">Combat</div>
          <div class="combat-groups">
            @for (group of combatPairings; track group.attackerIndex) {
              <div class="combat-group">
                <div class="combat-attacker-slot">
                  <div class="permanent-stack">
                    @for (aura of getAttachedAuras(group.attacker.id); track aura.perm.id) {
                      <app-card-display
                        [card]="aura.perm.card"
                        [permanent]="aura.perm"
                        class="attached-aura"
                        [class.targetable]="targeting && isValidTarget(aura.perm)"
                        (click)="onAuraClick(aura)"
                        (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                        (mouseleave)="onCardHoverEnd()" />
                    }
                    <app-card-display
                      [card]="group.attacker.card"
                      [permanent]="group.attacker"
                      [class.attacking]="group.attacker.attacking"
                      [class.selected-attacker]="declaringAttackers && isSelectedAttacker(group.attackerIndex)"
                      [class.block-target]="declaringBlockers && selectedBlockerIndex !== null && !group.attackerIsMine"
                      [class.targetable]="distributingDamage || (targeting && isValidTarget(group.attacker))"
                      [class.stack-targeted]="stackTargetId() === group.attacker.id"
                      (click)="onCombatAttackerClick(group)"
                      (contextmenu)="$event.preventDefault(); unassignDamage(group.attacker.id)"
                      (mouseenter)="onCardHover(group.attacker.card, group.attacker)"
                      (mouseleave)="onCardHoverEnd()">
                      <div class="card-combat-badge attacking-badge">Attacking</div>
                      @if (distributingDamage && getDamageAssigned(group.attacker.id) > 0) {
                        <div class="card-combat-badge damage-badge">{{ getDamageAssigned(group.attacker.id) }} dmg</div>
                      }
                    </app-card-display>
                  </div>
                </div>
                @if (group.blockers.length > 0) {
                  <div class="combat-blocker-slots">
                    @for (blocker of group.blockers; track blocker.index) {
                      <div class="permanent-stack">
                        @for (aura of getAttachedAuras(blocker.perm.id); track aura.perm.id) {
                          <app-card-display
                            [card]="aura.perm.card"
                            [permanent]="aura.perm"
                            class="attached-aura"
                            [class.targetable]="targeting && isValidTarget(aura.perm)"
                            (click)="onAuraClick(aura)"
                            (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                            (mouseleave)="onCardHoverEnd()" />
                        }
                        <app-card-display
                          [card]="blocker.perm.card"
                          [permanent]="blocker.perm"
                          class="blocking"
                          [class.stack-targeted]="stackTargetId() === blocker.perm.id"
                          (click)="onCombatBlockerClick(blocker)"
                          (mouseenter)="onCardHover(blocker.perm.card, blocker.perm)"
                          (mouseleave)="onCardHoverEnd()">
                          <div class="card-combat-badge blocking-badge">Blocking</div>
                        </app-card-display>
                      </div>
                    }
                  </div>
                }
              </div>
            }
          </div>
        </div>
      } @else {
        <div class="battlefield-divider"></div>
      }

      <div class="battlefield-row">
        <div class="battlefield-label">Your Battlefield</div>
        <div class="battlefield-sub-row creatures-row">
          @for (ip of myCreaturesNotInCombat(); track ip.originalIndex) {
            <div class="permanent-stack">
              @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                <app-card-display
                  [card]="aura.perm.card"
                  [permanent]="aura.perm"
                  class="attached-aura"
                  [class.targetable]="targeting && isValidTarget(aura.perm)"
                  (click)="onAuraClick(aura)"
                  (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              }
              <app-card-display
                [card]="ip.perm.card"
                [permanent]="ip.perm"
                [class.tapped]="ip.perm.tapped"
                [class.tappable]="canTapPermanent(ip.originalIndex) && !declaringAttackers && !declaringBlockers"
                [class.summoning-sick]="ip.perm.summoningSick"
                [class.can-attack]="canAttack(ip.originalIndex) && !isSelectedAttacker(ip.originalIndex)"
                [class.can-block]="canBlock(ip.originalIndex) && !isAssignedBlocker(ip.originalIndex) && selectedBlockerIndex !== ip.originalIndex"
                [class.selected-blocker]="selectedBlockerIndex === ip.originalIndex"
                [class.assigned-blocker]="isAssignedBlocker(ip.originalIndex)"
                [class.targetable]="targeting && isValidTarget(ip.perm)"
                [class.stack-targeted]="stackTargetId() === ip.perm.id"
                [class.choosable-permanent]="(choosingPermanent && choosablePermanentIds().has(ip.perm.id)) || (choosingMultiplePermanents && multiPermanentChoiceIds().has(ip.perm.id))"
                [class.selected-multi-permanent]="choosingMultiplePermanents && multiPermanentSelectedIds().has(ip.perm.id)"
                (click)="onMyBattlefieldCardClick(ip.originalIndex)"
                (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                (mouseleave)="onCardHoverEnd()" />
            </div>
          }
        </div>
        <div class="battlefield-sub-row lands-row">
          @for (item of myLandStacks; track $index) {
            @if (isLandStack(item)) {
              <div class="land-stack" [attr.data-stack-size]="item.lands.length">
                @for (ip of item.lands; track ip.originalIndex) {
                  <div class="land-stack-item">
                    <div class="permanent-stack">
                      @for (aura of getAttachedAuras(ip.perm.id); track aura.perm.id) {
                        <app-card-display
                          [card]="aura.perm.card"
                          [permanent]="aura.perm"
                          class="attached-aura"
                          [class.targetable]="targeting && isValidTarget(aura.perm)"
                          (click)="onAuraClick(aura)"
                          (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                          (mouseleave)="onCardHoverEnd()" />
                      }
                      <app-card-display
                        [card]="ip.perm.card"
                        [permanent]="ip.perm"
                        [class.tapped]="ip.perm.tapped"
                        [class.tappable]="canTapPermanent(ip.originalIndex) && !declaringAttackers && !declaringBlockers"
                        [class.targetable]="targeting && isValidTarget(ip.perm)"
                        [class.stack-targeted]="stackTargetId() === ip.perm.id"
                        [class.choosable-permanent]="(choosingPermanent && choosablePermanentIds().has(ip.perm.id)) || (choosingMultiplePermanents && multiPermanentChoiceIds().has(ip.perm.id))"
                        [class.selected-multi-permanent]="choosingMultiplePermanents && multiPermanentSelectedIds().has(ip.perm.id)"
                        (click)="onMyBattlefieldCardClick(ip.originalIndex)"
                        (mouseenter)="onCardHover(ip.perm.card, ip.perm)"
                        (mouseleave)="onCardHoverEnd()" />
                    </div>
                  </div>
                }
              </div>
            } @else {
              <div class="permanent-stack">
                @for (aura of getAttachedAuras(item.perm.id); track aura.perm.id) {
                  <app-card-display
                    [card]="aura.perm.card"
                    [permanent]="aura.perm"
                    class="attached-aura"
                    [class.targetable]="targeting && isValidTarget(aura.perm)"
                    (click)="onAuraClick(aura)"
                    (mouseenter)="onCardHover(aura.perm.card, aura.perm)"
                    (mouseleave)="onCardHoverEnd()" />
                }
                <app-card-display
                  [card]="item.perm.card"
                  [permanent]="item.perm"
                  [class.tapped]="item.perm.tapped"
                  [class.tappable]="canTapPermanent(item.originalIndex) && !declaringAttackers && !declaringBlockers"
                  [class.targetable]="targeting && isValidTarget(item.perm)"
                  [class.stack-targeted]="stackTargetId() === item.perm.id"
                  [class.choosable-permanent]="(choosingPermanent && choosablePermanentIds().has(item.perm.id)) || (choosingMultiplePermanents && multiPermanentChoiceIds().has(item.perm.id))"
                  [class.selected-multi-permanent]="choosingMultiplePermanents && multiPermanentSelectedIds().has(item.perm.id)"
                  (click)="onMyBattlefieldCardClick(item.originalIndex)"
                  (mouseenter)="onCardHover(item.perm.card, item.perm)"
                  (mouseleave)="onCardHoverEnd()" />
              </div>
            }
          }
        </div>
        @if (myBattlefield.length === 0) {
          <div class="battlefield-empty">No permanents</div>
        }
        @if (myGraveyard.length > 0) {
          <div class="graveyard-row">
            <div class="graveyard-label">Graveyard ({{ myGraveyard.length }})</div>
            <div class="graveyard-cards">
              @for (card of myGraveyard; track $index) {
                <app-card-display [card]="card" class="graveyard-card" (mouseenter)="onCardHover(card)" (mouseleave)="onCardHoverEnd()" />
              }
            </div>
          </div>
        }
      </div>
    </div>

    <div class="phase-tracker">
      @for (group of phaseGroups; track group.phaseName) {
        <div class="phase-group">
          <div class="phase-label">{{ group.phaseName }}</div>
          <div class="phase-steps">
            @for (stepInfo of group.steps; track stepInfo.step) {
              <div class="step-pip"
                   [class.active]="game()?.currentStep === stepInfo.step"
                   [class.auto-stop]="isAutoStop(stepInfo.step)"
                   [class.force-stop]="isForceStop(stepInfo.step)"
                   [title]="stepInfo.displayName"
                   (click)="toggleAutoStop(stepInfo.step)">
                {{ stepInfo.displayName }}
              </div>
            }
          </div>
        </div>
      }
    </div>

    @if (totalMana > 0) {
      <div class="mana-pool-bar">
        <div class="mana-pool">
          @for (entry of manaEntries; track entry.color) {
            <div class="mana-pip" [attr.data-color]="entry.color">
              <span class="mana-count">{{ entry.count }}</span>
            </div>
          }
        </div>
      </div>
    }

    @if (choosingFromHand) {
      <div class="combat-banner hand-choice-banner">
        <span>{{ handChoicePrompt }}</span>
        <button class="btn-confirm-combat" (click)="declineHandChoice()">Decline</button>
      </div>
    }

    @if (choosingColor) {
      <div class="combat-banner color-choice-banner">
        <span>{{ colorChoicePrompt }}</span>
        <div class="color-choice-buttons">
          @for (color of colorChoices; track color) {
            <button class="btn-color-choice" [attr.data-color]="color" (click)="chooseColor(color)">{{ getColorDisplayName(color) }}</button>
          }
        </div>
      </div>
    }

    @if (choosingAbility) {
      <div class="combat-banner ability-choice-banner">
        <span>Choose an ability to activate:</span>
        <div class="ability-choice-buttons">
          @for (choice of abilityChoices; track choice.index) {
            <button class="btn-confirm-combat" [disabled]="!choice.usable" (click)="chooseAbility(choice)">{{ choice.ability.description }}</button>
          }
        </div>
        <button class="btn-confirm-combat" (click)="cancelAbilityChoice()">Cancel</button>
      </div>
    }

    @if (choosingPermanent) {
      <div class="combat-banner permanent-choice-banner">
        <span>{{ permanentChoicePrompt }}</span>
      </div>
    }

    @if (choosingMultiplePermanents) {
      <div class="combat-banner permanent-choice-banner">
        <span>{{ multiPermanentChoicePrompt }} ({{ multiPermanentSelectedIds().size }}/{{ multiPermanentMaxCount }} selected)</span>
        <button class="btn-confirm-combat" (click)="confirmMultiPermanentChoice()">Confirm</button>
      </div>
    }

    <div class="hand-area">
      <div class="hand-label">Your Hand ({{ hand.length }} cards)</div>
      <div class="hand-cards">
        @for (card of hand; track $index) {
          <app-card-display
            [card]="card"
            [class.playable]="isCardPlayable($index)"
            [class.choosable-card]="choosingFromHand && isChoosableCard($index)"
            (click)="choosingFromHand ? chooseCardFromHand($index) : playCard($index)"
            (mouseenter)="onCardHover(card)"
            (mouseleave)="onCardHoverEnd()" />
        }
      </div>
    </div>
  }

  @if (gameOverWinner) {
    <div class="game-over-overlay">
      <div class="game-over-card">
        <h2>Game Over</h2>
        <p class="winner-text">{{ gameOverWinner }} wins!</p>
        <button class="btn-keep" (click)="backToLobby()">Back to Lobby</button>
      </div>
    </div>
  }

  @if (game()?.status === GameStatus.WAITING) {
    <div class="players-area">
      <div class="game-title">{{ game()?.gameName }}</div>
      <div class="player-card">
        <div class="player-label">Player 1</div>
        <div class="player-name">{{ player1Name }}</div>
      </div>

      <div class="vs-divider">VS</div>

      <div class="player-card">
        <div class="player-label">Player 2</div>
        @if (isWaitingForOpponent) {
          <div class="player-name waiting">Waiting for an opponent</div>
        } @else {
          <div class="player-name">{{ player2Name }}</div>
        }
      </div>
    </div>
  }
    </div>

    <div class="side-panel">
      <div class="card-preview-panel">
        @if (hoveredCard()) {
          <app-card-display [card]="hoveredCard()!" [permanent]="hoveredPermanent()" [preview]="true" class="preview-card" />
        } @else {
          <div class="card-preview-empty"></div>
        }
      </div>

      <div class="turn-info">
        <div class="player-badge" [class.active]="isActivePlayer(0)" [class.inactive]="!isActivePlayer(0)" [class.has-priority]="holdsPriority(0)" [class.targetable]="targetingForPlayer" [class.stack-targeted]="isStackTargetPlayer(0)" (click)="selectPlayerTarget(0)">
          {{ player1Name }}
          <span class="life-total">Life: {{ getLifeTotal(0) }}</span>
          <span class="deck-size">Deck: {{ player1DeckSize }}</span>
          @if (holdsPriority(0)) {
            <span class="priority-indicator">Priority</span>
          }
        </div>
        <div class="turn-center">
          <span class="turn-number">Turn {{ game()?.turnNumber }}</span>
          <span class="vs-label">VS</span>
        </div>
        <div class="player-badge" [class.active]="isActivePlayer(1)" [class.inactive]="!isActivePlayer(1)" [class.has-priority]="holdsPriority(1)" [class.targetable]="targetingForPlayer" [class.stack-targeted]="isStackTargetPlayer(1)" (click)="selectPlayerTarget(1)">
          {{ player2Name }}
          <span class="life-total">Life: {{ getLifeTotal(1) }}</span>
          <span class="deck-size">Deck: {{ player2DeckSize }}</span>
          @if (holdsPriority(1)) {
            <span class="priority-indicator">Priority</span>
          }
        </div>
      </div>

      <div class="action-bar">
        <button class="btn-pass" (click)="passPriority()" [disabled]="!hasPriority || declaringAttackers || declaringBlockers">Pass Priority</button>
      </div>

      @if (awaitingMayAbility) {
        <div class="combat-banner may-ability-banner">
          <span>{{ mayAbilityPrompt }}</span>
          <button class="btn-confirm-combat" (click)="acceptMayAbility()">Yes</button>
          <button class="btn-confirm-combat" (click)="declineMayAbility()">No</button>
        </div>
      }

      <div class="log-panel">
        <div class="log-header">Game Log</div>
        <div class="log-entries">
          @if (gameLog.length === 0) {
            <div class="log-entry empty">Waiting for game to start...</div>
          } @else {
            @for (entry of gameLog; track $index) {
              <div class="log-entry">{{ entry }}</div>
            }
          }
        </div>
      </div>
    </div>
  </div>
</div>
